(check (: mpz 0))


(declare formula type)
(declare th_holds (! f formula type))

; standard logic definitions
(declare true formula)
(declare false formula)
(declare not (! f formula formula))
(declare and (! f1 formula (! f2 formula formula)))
(declare or (! f1 formula (! f2 formula formula)))
(declare impl (! f1 formula (! f2 formula formula)))
(declare iff (! f1 formula (! f2 formula formula)))
(declare xor (! f1 formula (! f2 formula formula)))
(declare ifte (! b formula (! f1 formula (! f2 formula formula))))

; terms
(declare sort type)
(declare term (! t sort type))	; declared terms in formula


(declare mkt (! t sort (term t))) 

(check (\ I  (\ f  f)))

(check (: (! s sort (! _ (term s) (term s))) (\ I  (\ f  f))))

(check (mkt _))

(declare arrow (! s1 sort (! s2 sort sort)))	; function constructor

(declare Bool sort)
(declare true (term Bool))
(declare false (term Bool))

(declare Int sort) 
(declare int (! x mpz (term Int)))

; standard definitions for =, ite, let and flet
(declare = (! s sort
           (! x (term s)
           (! y (term s)
             formula))))

(declare symm (! s sort
              (! x (term s)
              (! y (term s)
              (! u (th_holds (= _ x y))
                (th_holds (= _ y x)))))))

(declare trans (! s sort
               (! x (term s)
               (! y (term s)
               (! z (term s)
               (! u (th_holds (= _ x y))
               (! u (th_holds (= _ y z))
                 (th_holds (= _ x z)))))))))

(declare trust_f (! f formula (th_holds f)))





(check (: formula (= Int (int 0) (int 1))))

(check (: formula (= _ (int 0) (int 1))))

(check (: (! x mpz (term Int)) (\ x (int 0))))


(check
 (: (th_holds (= _ (int _) (int 1)))
    (symm _ _ _
          (trust_f (= _ (int 1) (int 0))))
    ))

(define trust_eq_int
  (\ c (\ b (trust_f (= _ (int c) (int b))))))

(check
 (: (th_holds (= _ (int 0) (int 1)))
    (symm _ _ _
          (trust_eq_int 1 0))
    ))

(check (: (term _) ((\ x (int x)) 0)))


(declare apply (! s1 sort
               (! ss2 sort
               (! t1 (term (arrow s1 ss2))
               (! t2 (term s1)
                (term ss2))))))


(check (: (! s sort (! _ (term s) (term s))) (\ I  (\ f  f))))

(define id (% I sort (% f (term I) f)))

(check (% s sort (% x (term (arrow Int s)) (id (apply _ _ x (int 0))))))

(declare array (! s1 sort (! s2 sort sort)))	; s1 is index, s2 is element

; functions
(declare write (! s1 sort
               (! s2 sort
                 (term (arrow (array s1 s2)
                       (arrow s1
                       (arrow s2 (array s1 s2))))))))


(declare read (! s1 sort
              (! s2 sort
              	(term (arrow (array s1 s2)
               	      (arrow s1 s2))))))



(declare s1 sort)
(declare s2 sort)
(declare t1 (term (array s1 s2)))
 
(check ;; (% s1 sort
       ;; (% s2 sort
       ;; (% t1 (term (array s1 s2))
       ;; (% t2 (term s1)
       ;; (% t3 (term s2)

          (apply (array s1 s2)
                 (arrow s1 (arrow s2 (array s1 s2)))
                 (write s1 s2) t1)
          
          )
;; )))
;; ))
          
;; ; inference rules
(declare row1 (! s1 sort
              (! s2 sort
              (! t1 (term (array s1 s2))
              (! t2 (term s1)
              (! t3 (term s2)
              	(th_holds (= _ (apply _ _ (apply _ _ (read s1 s2) (apply _ _ (apply _ _ (apply _ _ (write s1 s2) t1) t2) t3)) t2)
              		       t3))))))))
